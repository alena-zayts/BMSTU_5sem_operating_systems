\chapter{Функции обработчика прерывания от системного таймера}

\section{Unix}

% 187 вахалия
По тику:

\begin{itemize}
	\item инкремент счётчика тиков аппаратного таймера;
	\item инкремент часов и других таймеров системы;
	\item обновление статистики использования процессора текущим процессом (инкрементмент поля p\_cpu дескриптора текущего процесса до максимального значения, равного 127);
	\item декремент счетчика времени, оставшегося до отправления на выполнение отложенных вызовов, при достижении нулевого значения счетчика -- выставление флага, указывающего на необходимость запуска обработчика отложенного вызова;
	\item декремент кванта текущего потока.
\end{itemize}

По главному тику: 
\begin{itemize}
	\item регистрация отложенных вызовов функций, относящихся к работе планировщика,
	таких как пересчет приоритетов;
	\item пробуждение (то есть регистрирация отложенного вызова процедуры wakeup, которая перемещает дескриптор процесса из списка “спящих” в очередь "готовых к выполнению") системных процессов {\ttfamily swapper} и {\ttfamily pagedaemon};
	\item декремент счётчика времени, оставшегося до посылки одного из следующих сигналов:
	\begin{itemize}
		\item {\ttfamily SIGALRM} – сигнал, посылаемый процессу по истечении времени, заданного функцией {\ttfamily alarm()} (будильник реального времени);
		\item {\ttfamily SIGPROF} –  сигнал, посылаемый процессу по истечении времени, заданного в таймере профилирования (будильник профиля процесса);
		\item {\ttfamily SIGVTALRM} –  сигнал, посылаемый процессу по истечении времени работы в режиме задачи (будильник виртуального времени).
	\end{itemize}
\end{itemize}

По кванту:
\begin{itemize}
	\item если текущий процесс превысил выделенный ему квант процессорного времени, отправка ему сигнала SIGXCPU.
\end{itemize}

\section{Windows}

По тику:
\begin{itemize}
	\item инкремент счётчика системного времени;
	\item декремент остатка кванта текущего потока;
	\item декремент счётчиков отложенных задач;
	\item добавление процесса в очередь DPC (Deferred procedure call, отложенный вызов процедуры). 
\end{itemize}

По главному тику: 
\begin{itemize}
	\item инициализация диспетчера настройки баланса путем освобождения объекта <<событие>>, на котором он ожидает.
\end{itemize}

По кванту:
\begin{itemize}
	\item инициация диспетчеризации потоков добавлением соответствующего объекта в очередь DPC.
\end{itemize}

\chapter{Пересчёт динамических приоритетов}

Динамические приоритеты могут быть только у пользовательских процессов. В операционных системах процесс является владельцем ресурсов, в том числе владельцем приоритета.

\section{Unix}

Очередь готовых к выполнению процессов формируется согласно приоритетам процессов и принципу вытесняющего циклического планирования: процессы с одинаковыми приоритетами выполняются в течении кванта времени циклически друг за другом. Если процесс, имеющий более высокий приоритет, поступает в очередь готовых к выполнению, планировщик вытесняет текущий процесс и предоставляет ресурс более приоритетному. 

В современных системах {\ttfamily Unix} ядро является вытесняющим – процесс в режиме ядра может быть вытеснен более приоритетным процессом в режиме ядра.

 

Дескриптор процесса proc содержит следующие поля, относящиеся к приоритету:

\subsection{Приоритеты процессов}

Приоритет процесса в {\ttfamily UNIX} задаётся числом в диапазоне от 0 до 127, причём чем меньше значение, тем выше приоритет. Приоритеты 0--49 зарезервированы ядром операционной системы, прикладные процессы могут обладать приоритетом в диапазоне от 50 до 127. Приоритеты ядра являются фиксированными величинами.

Приоритеты прикладных задач могут изменяться во времени в зависимости от следующих двух факторов:

\begin{itemize}
	\item фактор любезности – целое число в диапазоне от 0 до 39. Чем меньше значение фактора любезности, тем выше приоритет процесса. Фактор любезности процесса может быть изменён суперпользователем системным вызовом {\ttfamily nice};
	
	\item степень загруженности процессора в момент последнего обслуживания им процесса.
\end{itemize}

Структура \code{proc} содержит следующие поля, относящиеся к приоритетам:
\begin{itemize}
	\item \code{p{\_}pri} -- текущий приоритет планирования;
	\item \code{p{\_}usrpri} -- приоритет режима задачи;
	\item \code{p{\_}cpu} -- результат последнего измерения использования процессора;
	\item \code{p{\_}nice} -- показатель уступчивости, устанавливаемый пользователем.
\end{itemize}

Планировщик использует поле \code{p{\_}pri} для принятия решения о том, какой процесс отправить на выполнение. Значения \code{p{\_}pri} и \code{p{\_}usrpri} одинаковы, когда процесс находится в режиме задачи. Когда процесс просыпается после блокировки в системном вызове, его приоритет временно повышается. Планировщик использует \code{p{\_}usrpri} для хранения приоритета, который будет назначен процессу при переходе из режима ядра в режим задачи, а \code{p{\_}pri} -- для хранения временного приоритета для выполнения в режиме ядра.

Ядро связывает приоритет сна (0--49) с событием или ожидаемым ресурсом, из-за которого процесс может быть заблокирован. Когда блокированный процесс просыпается, ядро устанавливает \code{p{\_}pri}, равное приоритету сна события или ресурса, на котором он был заблокирован, следовательно, такой процесс будет назначен на выполнение раньше, чем другие процессы в режиме задачи. 

В таблице \ref{tbl:sleeppriority} приведены значения приоритетов сна для систем {\ttfamily 4.3BSD UNIX} и {\ttfamily SCO UNIX}. Такой подход позволяет системным вызовам быстрее завершать свою работу. По завершении процессом системного вызова его приоритет сбрасывается в значение текущего приоритета в режиме задачи. Если при этом приоритет окажется ниже, чем приоритет другого запущенного процесса, ядро произведет переключение контекста.
\begin{table}[h]
	\caption{Системные приоритеты сна}
	\begin{center}
		\begin{tabular}{|l|p{75pt}|p{75pt}|} 
			\hline
			\textbf{Событие} & \textbf{Приоритет 4.3BSD UNIX} & \textbf{Приоритет SCO UNIX}\\
			\hline
			{Ожидание загрузки в память страницы} & 0 & 95\\
			\hline
			{Ожидание индексного дескриптора} & 10 & 88\\
			\hline
			{Ожидание ввода--вывода} & 20 & 81 \\
			\hline
			{Ожидание буфера} & 30 & 80\\
			\hline
			{Ожидание терминального ввода} & 30 & 75\\
			\hline
			{Ожидание терминального вывода} & 30 & 74\\
			\hline
			{Ожидание завершения выполнения} & 30 & 73\\
			\hline
			{Ожидание события} & 40 & 66\\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:sleeppriority}
\end{table}

Приоритет в режиме задачи зависит от уступчивости и последней измеренной величины использования процессора. Степень уступчивости -- это число в диапазоне от 0 до 39 со значением 20 по умолчанию. 

Системы разделения времени стараются выделить процессорное время таким образом, чтобы все процессы системы получили его в равных количествах, что требует слежения за использованием процессора. Поле {\ttfamily p{\_}cpu} содержит величину последнего измерения использования процессора процессом. При создании процесса это поле инициализируется нулем. На каждом тике обработчик таймера увеличивает {\ttfamily p{\_}cpu} на единицу для текущего процесса, вплоть до максимального значения -- 127. Каждую секунду ядро вызывает процедуру {\ttfamily schedcpu}, которая уменьшает значение {\ttfamily p{\_}cpu} каждого процесса исходя из фактора <<полураспада>>. 

В {\ttfamily 4.3BSD} для расчета применяется формула
\[
d = \frac{2\cdot la}{2\cdot la + 1},
\]
где {\ttfamily la} -- {\ttfamily load{\_}average} -- это среднее количество процессов в состоянии готовности за последнюю секунду.

Кроме того, процедура {\ttfamily schedcpu} также пересчитывает приоритеты режима задачи всех процессов по формуле
\[
{p_{usrpri}} = PUSER + \frac{p{\_}cpu}{4} + 2\cdot {p{\_}nice},
\]
где {\ttfamily PUSER} -- базовый приоритет в режиме задачи, равный 50.

Если процесс до вытеснения другим процессом использовал большое количество процессорного времени, его {\ttfamily p{\_}cpu} будет увеличен, что приведет к увеличению значения {\ttfamily p{\_}usrpri} и к понижению приоритета.

Чем дольше процесс простаивает в очереди на выполнение, тем меньше его {\ttfamily p{\_}cpu}. Это позволяет предотвратить зависания низкоприоритетных процессов. Если процесс б\'{о}льшую часть времени выполнения тратит на ожидание ввода-вывода, то он остается с высоким приоритетом.

Системы разделения времени пытаются выделить процессорное время таким образом, чтобы конкурирующие процессы получили его примерно в равных количествах. Фактор полураспада обеспечивает экспоненциально взвешанное среднее значение использования процессора в течение функционирования процесса. Формула, применяемая в SVR3 имеет недостаток: вычисляя простое экспоненциальное среднее, она способствует росту приоритетов при увеличении загрузки системы.

\section{Windows-системы}
%475 Р
В Windows реализуется приоритетная, вытесняющая система планирования, при  которой всегда выполняется хотя бы один работоспособный (готовый) поток с самым высоким приоритетом. 

После того как поток был выбран для запуска, он запускается на время, называемое квантом. Но поток может и не израсходовать свой квант времени: если становится готов к запуску другой поток с более высоким приоритетом, текущий выполняемый поток может быть вытеснен.

Единого модуля под названием «планировщик» не существует. Процедуры, выполняющие обязанности по диспетчеризации, обобщенно называются диспетчером ядра.   Диспетчеризации потоков могут потребовать следующие события:

\begin{itemize}
	\item поток становится готовым к выполнению;
	\item поток выходит из состояния выполнения из-за окончания его кванта времени;
	\item поток завершается или переходит в состояние ожидания;
	\item изменяется приоритет потока;
	\item изменяется родственность процессора потока.
\end{itemize}


Windows использует 32 уровня приоритета, от 0 до 31. Эти значения  разбиваются на части следующим образом:
\begin{itemize}
		\item шестнадцать уровней реального времени (от 16 до 31);
		\item шестнадцать изменяющихся уровней (от 0 до 15), из которых уровень 0 зарезервирован для потока обнуления страниц. 
\end{itemize}
 

Уровни приоритета потоков назначаются из двух разных позиций: от Windows API и от ядра Window.

Windows API систематизирует процессы по классу приоритета, который присваивается им при их создании:
\begin{itemize}
	\item реального времени (real-time (4));
	\item высокий (high (3));
	\item выше обычного (above normal (7));
	\item обычный (normal (2));
	\item ниже обычного (below normal (5));
	\item простой (idle (1)).
\end{itemize}

Затем назначается относительный приоритет потоков в рамках процессов. Здесь номера представляют изменение приоритета, применяющееся к базовому приоритету процесса:
\begin{itemize}
	\item критичный по времени (time-critical (15));
	\item наивысший (highest (2));
	\item выше обычного (above normal (1));
	\item обычный (normal (0));
	\item ниже обычного (below -normal (-1));
	\item самый низший (lowest (-2));
	\item простоя (idle (-15)).
\end{itemize}

Уровень, критичный по времени, и уровень простоя (+15 и –15) называются уровнями насыщения и представляют конкретные применяемые уровни вместо смещений.

Относительный приоритет -- это приращение к базовому приоритету процесса.
 

Соответствие между приоритетами Windows API и ядра системы приведено в таблице \ref{tbl:priority}.
\begin{table}[h]
	\caption{Соответствие между приоритетами Windows API и ядра Windows}
	\begin{center}
		\begin{tabular}{|l|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|} 
			\hline
			{} & \textbf{real-time} & \textbf{high} & \textbf{above normal} & \textbf{normal} & \textbf{below normal} & \textbf{idle}\\
			\hline
			\textbf{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
			\hline
			\textbf{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
			\hline
			\textbf{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
			\hline
			\textbf{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
			\hline
			\textbf{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
			\hline
			\textbf{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
			\hline
			\textbf{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priority}
\end{table}

Процесс обладает только базовым приоритетом, тогда как поток имеет базовый, который наследуется от приоритета процесса, и текущий приоритет. Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал. 

Приложения пользователя обычно запускаются с базовым приоритетом (normal), поэтому их исходный поток чаще всего выполняется с уровнем приоритета 8. 


Повышение приоритета вступает в действие немедленно и может  вызвать изменения в планировании процессора. Однако если поток использует весь свой следующий квант, то он теряет один уровень приоритета и перемещается вниз на одну очередь в массиве приоритетов. Если же он использует второй полный квант, то он перемещается вниз еще  на один уровень, и так до тех пор, пока не дойдет до своего базового уровня. Повышение приоритета потока в Windows применяется только для потоков с приоритетом динамического диапазона (0-15). Но каким бы ни было приращение, приоритет потока никогда не будет больше 15. 

Сценарии повышения приоритета:
\begin{itemize}
	\item Повышение приоритета владельца блокировки.
	\item Повышение вследствие завершения ввода-вывода (сокращение задержек -- поток может вновь быстро запуститься и начать новую операцию ввода-вывода).
	\item Повышение вследствие ввода из пользовательского интерфейса (сокращение задержек и времени отклика).
	\item Повышение вследствие слишком продолжительного ожидания ресурса исполняющей системы (предотвращение зависания).
	\item Повышение в случае, когда готовый к запуску поток не был запущен в течение определенного времени (предотвращение зависания и смены приоритетов).
	\item Если поток ждал на семафоре, мьютексе или другом событии, то 	при его освобождении он получает повышение приоритета на два 	уровня, если находится в фоновом процессе, и на один уровен	во всех остальных случаях;
	\item Повышение приоритета проигрывания мультимедиа, управляемое службой MMCSS (это не является настоящим повышением, служба устанавливает по необходимости новые базовые приоритеты для потоков).
\end{itemize}


\chapter*{Вывод}

Функции обработчика прерывания от системного таймера для семейства ОС {\ttfamily Windows} и для семейства OC {\ttfamily UNIX/Linux} схожи по своим действиям:
\begin{itemize}
	\item инициализируют отложенные действия, относящиеся к работе планировщика, такие как пересчёт приоритетов;
	\item выполняют декремент счётчиков времени: часов, таймеров, будильников реального времени, счётчиков времени отложенных действий;
	\item выполняют декремент кванта: текущего процесса в {\ttfamily Linux}, текущего потока в {\ttfamily Windows}.
\end{itemize}

Такая схожесть объясняется тем, что обе системы являются системами разделения времени с динамическими приоритетами и вытеснением.

